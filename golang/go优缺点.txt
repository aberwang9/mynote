优点：
		1. 基于 goroutines 和 channels 的简单并发编程
			Goroutines 可能是 Go 的最佳特性了。它们是轻量级的计算线程，与操作系统线程截然不同。

			当 Go 程序执行看似阻塞 I/O 的操作时，实际上 Go 运行时挂起了 goroutine ,当一个事件指示某个结果可用时恢复它。与此同时，其他的 goroutines 已被安排执行。因此在同步编程模型下，我们具有了异步编程的可伸缩性优势。

			Goroutines 也是轻量级的:它们的堆栈 随需求增长和收缩，这意味着有 100 个甚至 1000 个 goroutines 都不是问题。

			我以前的应用程序中有一个 goroutine 漏洞:这些 goroutines 结束之前正在等待一个 channel 关闭，而这个 channel 永远不会关闭(一个常见的死锁问题)。这个进程毫无任何理由吃掉了 90 % 的 CPU ，而检查 expvars 显示有 600 k 空闲的 goroutines! 我猜测 goroutine 调度程序占用了 CPU。

			当然，像 Akka 这样的 Actor 系统可以轻松 处理数百万的 Actors，部分原因是 actors 没有堆栈，但是他们远没有像 goroutines 那样简单地编写大量并发的请求/响应应用程序（即 http APIs）。

			channel 是 goroutines 的通信方式:它们提供了一个便利的编程模型，可以在 goroutines 之间发送和接收数据，而不必依赖脆弱的低级别同步基本体。channels 有它们自己的一套 用法 模式。

			但是，channels 必须仔细考虑，因为错误大小的 channels (默认情况下没有缓冲) 会导致死锁。下面我们还将看到，使用通道并不能阻止竞争情况，因为它缺乏不可变性。

		2. 丰富的标准库
			Go 的 标准库 非常丰富,特别是对于所有与网络协议或 API 开发相关的: http 客户端和服务器，加密，档案格式，压缩，发送电子邮件等等。甚至还有一个html解析器和相当强大的模板引擎去生成 text & html，它会自动过滤 XSS 攻击（例如在 Hugo 中的使用）。

			各种 APIs 一般都简单易懂。它们有时看起来过于简单:这个某种程度上是因为 goroutine 编程模型意味着我们只需要关心“看似同步”的操作。这也是因为一些通用的函数也可以替换许多专门的函数，就像 我最近发现的关于时间计算的问题。

		3. Go 性能优越
			Go 编译为本地可执行文件。许多 Go 的用户来自 Python、Ruby 或 Node.js。对他们来说，这是一种令人兴奋的体验，因为他们看到服务器可以处理的并发请求数量大幅增加。当您使用非并发(Node.js)或全局解释器锁定的解释型语言时，这实际上是相当正常的。结合语言的简易性，这解释了 Go 令人兴奋的原因。

			然而与 Java 相比，在 原始性能基准测试 中，情况并不是那么清晰。Go 打败 Java 地方是内存使用和垃圾回收。

			Go 的垃圾回收器的设计目的是 优先考虑延迟，并避免停机，这在服务器中尤其重要。这可能会带来更高的 CPU 成本，但是在水平可伸缩的体系结构中，这很容易通过添加更多的机器来解决。请记住，Go 是由谷歌设计的，他们从不会在资源上面短缺。

			与 Java 相比，Go 的垃圾回收器（GC）需要做的更少:切片是一个连续的数组结构，而不是像 Java 那样的指针数组。类似地，Go maps 也使用小数组作为 buckets，以实现相同的目的。这意味着垃圾回收器的工作量减少，并且 CPU 缓存本地化也更好。

			Go 同样在命令行实用程序中优于 Java :作为本地可执行文件，Go 程序没有启动消耗，反之 Java 首先需要加载和编译的字节码。

		4. 语言层面定义源代码的格式化
			我职业生涯中一些最激烈的辩论发生在团队代码格式的定义上。 Go 通过为代码定义规范格式来解决这个问题。 gofmt 工具会重新格式化您的代码，并且没有选项。

			不管你喜欢与否，gofmt 定义了如何对代码进行格式化，一次性解决了这个问题。

		5. 标准化的测试框架
			Go 在其标准库中提供了一个很好的 测试框架。它支持并行测试、基准测试，并包含许多实用程序，可以轻松测试网络客户端和服务器。


		6. Go 程序方便操作
			与 Python，Ruby 或 Node.js 相比，必须安装单个可执行文件对于运维工程师来说是一个梦想。 随着越来越多的 Docker 的使用，这个问题越来越少，但独立的可执行文件也意味着小型的 Docker 镜像。

			Go还具有一些内置的观察性功能，可以使用 expvar 包发布内部状态和指标，并易于添加新内容。但要小心，因为它们在默认的 http 请求处理程序中 自动公开，不受保护。Java 有类似的 JMX ，但它要复杂得多。

缺点
	1. Go 忽略了现代语言设计的进步
		在少既是多中，Rob Pike 解释说 Go 是为了在谷歌取代 C 和 C++，它的前身是 Newsqueak ，这是他在80年代写的一种语言。Go 也有很多关于 Plan9 的参考，Plan9 是一个分布式操作系统，在贝尔实验室的80年代开发的。

		甚至有一个直接从 Plan9 获得灵感的Go 汇编。为什么不使用 LLVM 来提供目标范围广泛且开箱即用的体系结构?我此处可能也遗漏了某些东西，但是为什么需要汇编?如果你需要编写汇编以充分利用 CPU ，那么不应该直接使用目标 CPU 汇编语言吗?

		Go 的创造者应该得到尊重，但是看起来 Go 的设计发生在平行宇宙（或者他们的 Plan9 lab?）中发生的，这些编译器和编程语言的设计在 90 年代和 2000 年中从未发生过。也可能 Go 是由一个会写编译器的系统程序员设计的。

		函数式编程吗？不要提它。泛型？你不需要，看看他们用 C++ 编写的烂摊子!尽管 slice、map 和 channel 都是泛型类型，我们将在下面看到。

		Go 的目标是替换 C 和 C++，很明显它的创建者也没有关注其他地方。但他们没有达到目标，因为在谷歌的 C 和 C++ 开发人员没有采用它。我的猜测是主要原因是垃圾回收器。低级别 C 开发人员强烈拒绝托管内存，因为他们无法控制什么时间发生什么情况。他们喜欢这种控制，即使它带来了额外的复杂性，并且打开了内存泄漏和缓冲溢出的大门。有趣的是，Rust 在没有 GC 的情况下采用了完全不同的自动内存管理方法。

		Go 反而在操作工具的领域吸引了 Python 和 Ruby 等脚本语言的用户。他们在 Go 中找到了一种方法，可以提高性能，减少 内存/cpu/磁盘 占用。还有更多的静态类型，这对他们来说是全新的。Go 的杀手级应用是 Docker ，它在 devops 世界中引起了广泛的应用。Kubernetes 的崛起加强了这一趋势。

	2.	接口是结构类型
		Go 接口就像 Java 接口或 Scala 和 Rust 特性（traits）:它们定义了后来由类型实现的行为（我不称之为“类”）。

		与 Java 接口和 Scala 和 Rust 特性不同，类型不需要显式地指定接口实现:它只需要实现接口中定义的所有函数。所以 Go 的接口实际上是结构化的。

		我们可能认为，这是为了允许其他包中的接口实现，而不是它们适用的类型，比如 Scala 或 Kotlin 中的类扩展，或 Rust 特性，但事实并非如此:所有与类型相关的方法都必须在类型的包中定义。

		Go 并不是唯一使用结构化类型的语言，但我发现它有几个缺点:

		找到实现给定接口的类型很难，因为它依赖于函数定义匹配。我通过搜索实现接口的类，经常发现 Java 或 Scala 中有趣的实现。
		当向接口添加方法时，只有当它们用作此接口类型的值时，才会发现哪些类型需要更新。 相当一段时间这可能被忽视。 Go 建议使用非常少的方法构建小型的接口，这是防止这种情况的一种方式。
		类型可能在不知不觉中实现了一个接口，因为它作为相应的方法。但是偶然的，实现的语义可能与接口契约所期望的不同。
		更新 : 对于接口的一些丑陋问题，请参阅下面的 无接口值（nil interface values）。

	3.	没有枚举
		Go 没有枚举，在我看来，这是一个错失的机会。

		iota 可以快速生成自动递增的值，但它看起来更像一个技巧 而不是一个特性。实际上，由于在一系列的 iota 生成的常量中插入一行会改变下列值的值，这是很危险的。由于生成的值是在整个代码中使用的值，因此这会导致有趣的（而不是!）意外。

		这也意味着没有办法让编译器彻底检查 switch 语句，也无法描述类型中允许的值。

	:= / var 两难选择
	Go 提供两种方法来声明一个变量，并为其赋值: var x = "foo" 和x:= "foo"。这是为什么呢?

	主要的区别是 var 允许未初始化的声明(然后您必须声明类型)，比如在 var x string 中，而 := 需要赋值，并且允许混合使用现有变量和新变量。我的猜测是:=被发明来使错误处理减少一点麻烦:

	使用 var

	var x, er


