	内联函数在C++中可以用inline来定义内联函数，例如：

	inline int min(int a, int b)
	{
	 return a > b ? b : a;

	}

	如果想要用内联函数，那么该函数的代码逻辑不要超过10行，尽量保证代码的短小精悍。体量大的代码逻辑不适合当做内联函数使用。

	为什么要这样考虑？废话少说，原因是这样的，使用内联函数主要目的是为了提高代码的执行效率。

	那么为什么要用内联函数来提高代码执行效率呢？

	因为如果不是内联函数而是普通函数的话，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行，然后执行完了之后，还要再恢复现场，类似中断那种。
	这样的操作无疑是较为消耗时间的。

	当使用了内联函数之后，程序在运行时，遇到调用内联函数的地方时，不需要再保存现场恢复现场等一系列的动作，而是内联的将调用函数的地方改成代码的样子，这样就省下了较多的时间。至于怎么内联的展开的，这个我还不太清楚，研究一下之后再来补充。

	为什么不要写10行以上的逻辑函数当做内联函数呢？

	这是因为内联函数是典型的以空间换时间，会增加内存资源的消耗，如果代码量过大，空间换时间的优势就没有了，反而可能会降低时间性能，因此在使用内联函数的时候，尽量短小精悍。

	那么java中的内联函数是怎么样的呢？

	java中的内联函数只能说是用final修饰的函数可以被当做内联函数用，jvm会分析final函数，自动判断是否当做内联函数使用，如果当做内联函数执行效率更好，那么会将其当做内联函数进行处理。

	总结一下：

	1、内联函数是以空间换时间

	2、内联函数会占用更多的内存，因此需要考量其大小

	3、内联函数使用得当会提升效率。

	4、C++中用inline定义内联函数；java中需要用final修饰函数，是由jvm进行自动判断的。

	 思考：内联函数：相当于程序在running时，将内联函数的字节码，直接嵌入到被调用者的字节码中，
	 
	 时间和空间：
		空间和时间比较，假设调用一个函数之前的准备工作和之后的善后工作的指令所需空间大小为SS，执行这些代码所需时间为TS。
		        （1）空间。如果一个函数的函数体代码大小为AS，在程序中被调用N次，不采用内联的情况下，空间开销为：SS*N+AS。采用内联：AS*N。因为N一般很大，所以它们之间的比较就是SS跟AS的比较，得出的结论是：如果SS小于AS，不采用内联，空间开销更少。如果AS小于SS，则采用内联，空间开销更少。

		        （2）时间。内联之后每次调用不再需要做函数调用的准备和善后工作；内联之后编译器获得更多的代码信息，看到的是调用函数与被调用函数连成的一大块代码，此时编译器对代码的优化可以做得更好。还有一个很重要的因素，即内联后调用函数体内需要执行的代码是相邻的，其执行的代码都在同一个页面或连续的页面中。如果没有内联，执行到被调用函数时，需要跳到包含被调用函数的内存页面中执行，而被调用函数所属的页面极有可能当时不在物理内存中。这意味着，内联后可以降低“缺页”的几率，“缺页”次数的减少带来的效果远好于代码量的减少。另外即使被调用函数所在的页面可能正好在物理内存中，但是因为与调用函数在空间上相隔甚远，所以可能会引起“Cache miss”，从而降低执行速度。因此总的来说，内联后程序的执行时间会比没有内联要少，即程序速度更快。不过，如果内联的函数非常大的话，正如前面提到的，当AS远大于SS，且N很大时，会使最终程序的代码量增多，代码量多意味着用来存放代码的内存页面增多，“缺页”也会相应增加，速度反而下降，所以很大的函数不适合内联。这也是为什么很多编译器对于函数体代码很多的函数，会拒绝对其进行内联的请求。即忽略"inline"关键字，而对如同普通函数那样编译。

        最后顺带提及，一个程序的唯一入口main()函数肯定不会被内联化。另外编译器合成的默认构造函数、拷贝构造函数、析构函数以及赋值运算符一般都被内联化。


	 


	 
	public final void function(){

	//TODO

	}

			该方法在被调用时，会在调用处直接展开使用，从而提高程序执行速度。

		 一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把函数变成内联函数